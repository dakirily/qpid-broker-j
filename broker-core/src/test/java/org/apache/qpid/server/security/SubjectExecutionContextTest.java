/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */

package org.apache.qpid.server.security;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import javax.security.auth.Subject;

import org.junit.jupiter.api.Test;

import org.apache.qpid.test.utils.UnitTestBase;

class SubjectExecutionContextTest extends UnitTestBase
{
    private static final String SUBJECT_MUST_BE_NULL_OUTSIDE_CONTEXT = "Subject must be null outside context";
    private static final String SUBJECT_MUST_BE_RESTORED_AFTER_CONTEXT = "Subject must be restored after context";

    @Test
    void testWithSubjectRestoresPreviousSubject()
    {
        final Subject subjectA = new Subject();
        final Subject subjectB = new Subject();

        assertNull(SubjectExecutionContext.currentSubject(), SUBJECT_MUST_BE_NULL_OUTSIDE_CONTEXT);

        SubjectExecutionContext.withSubject(subjectA, () ->
        {
            assertEquals(subjectA, SubjectExecutionContext.currentSubject(), "Unexpected subject in outer context");

            SubjectExecutionContext.withSubject(subjectB, () ->
                    assertEquals(subjectB, SubjectExecutionContext.currentSubject(), "Unexpected subject in inner context"));

            assertEquals(subjectA, SubjectExecutionContext.currentSubject(), "Unexpected subject after inner context");
        });

        assertNull(SubjectExecutionContext.currentSubject(), SUBJECT_MUST_BE_RESTORED_AFTER_CONTEXT);
    }

    @Test
    void testWithSubjectRunnableRestoresPreviousSubject()
    {
        final Subject subjectA = new Subject();
        final Subject subjectB = new Subject();

        assertNull(SubjectExecutionContext.currentSubject(), SUBJECT_MUST_BE_NULL_OUTSIDE_CONTEXT);

        SubjectExecutionContext.withSubject(subjectA, () ->
        {
            assertEquals(subjectA, SubjectExecutionContext.currentSubject(), "Unexpected subject in outer context");

            SubjectExecutionContext.withSubject(subjectB, () ->
                    assertEquals(subjectB, SubjectExecutionContext.currentSubject(), "Unexpected subject in inner context"));

            assertEquals(subjectA, SubjectExecutionContext.currentSubject(), "Unexpected subject after inner context");
        });

        assertNull(SubjectExecutionContext.currentSubject(), SUBJECT_MUST_BE_RESTORED_AFTER_CONTEXT);
    }

    @Test
    void testWithSubjectRestoresAfterException()
    {
        final Subject subject = new Subject();
        final Exception expected = new Exception("boom");

        final Exception thrown = assertThrows(Exception.class, () ->
                SubjectExecutionContext.withSubject(subject, (Callable<Void>) () ->
                {
                    throw expected;
                }));

        assertSame(expected, thrown, "Unexpected exception");
        assertNull(SubjectExecutionContext.currentSubject(), "Subject must be restored after exception");
    }

    @Test
    void testWithSubjectRunnableRestoresAfterException()
    {
        final Subject subject = new Subject();
        final RuntimeException expected = new RuntimeException("boom");

        final RuntimeException thrown = assertThrows(RuntimeException.class, () ->
                SubjectExecutionContext.withSubject(subject, (Runnable) () ->
                {
                    throw expected;
                }));

        assertSame(expected, thrown, "Unexpected exception");
        assertNull(SubjectExecutionContext.currentSubject(), "Subject must be restored after exception");
    }

    @Test
    void testWithSubjectRunnableRestoresAfterNestedException()
    {
        final Subject subjectA = new Subject();
        final Subject subjectB = new Subject();
        final RuntimeException expected = new RuntimeException("boom");

        assertNull(SubjectExecutionContext.currentSubject(), SUBJECT_MUST_BE_NULL_OUTSIDE_CONTEXT);

        SubjectExecutionContext.withSubject(subjectA, () ->
        {
            assertEquals(subjectA, SubjectExecutionContext.currentSubject(), "Unexpected subject in outer context");

            try
            {
                SubjectExecutionContext.withSubject(subjectB, (Runnable) () ->
                {
                    assertEquals(subjectB, SubjectExecutionContext.currentSubject(), "Unexpected subject in inner context");
                    throw expected;
                });
            }
            catch (RuntimeException thrown)
            {
                assertSame(expected, thrown, "Unexpected exception");
            }

            assertEquals(subjectA,
                    SubjectExecutionContext.currentSubject(),
                    "Unexpected subject after inner exception");
        });

        assertNull(SubjectExecutionContext.currentSubject(), SUBJECT_MUST_BE_RESTORED_AFTER_CONTEXT);
    }

    @Test
    void testNewThreadDoesNotInheritSubject() throws Exception
    {
        final Subject subject = new Subject();
        final CountDownLatch latch = new CountDownLatch(1);
        final AtomicReference<Subject> threadSubjectCapture = new AtomicReference<>();

        SubjectExecutionContext.withSubject(subject, () ->
        {
            Thread thread = new Thread(() ->
            {
                threadSubjectCapture.set(SubjectExecutionContext.currentSubject());
                latch.countDown();
            });
            thread.start();
        });

        assertTrue(latch.await(3, TimeUnit.SECONDS), "Thread did not start in time");
        assertNull(threadSubjectCapture.get(), "Unexpected subject in new thread");
    }

    @Test
    void testWithSubjectUncheckedWrapsCheckedException()
    {
        final Subject subject = new Subject();
        final Exception expected = new Exception("boom");

        final SubjectActionException thrown = assertThrows(SubjectActionException.class, () ->
                SubjectExecutionContext.withSubjectUnchecked(subject, (Callable<Void>) () ->
                {
                    throw expected;
                }));

        assertSame(expected, thrown.getCause(), "Unexpected wrapped exception");
        assertNull(SubjectExecutionContext.currentSubject(), "Subject must be restored after exception");
    }

    @Test
    void testWithSubjectUncheckedRethrowsRuntimeException()
    {
        final Subject subject = new Subject();
        final RuntimeException expected = new RuntimeException("boom");

        final RuntimeException thrown = assertThrows(RuntimeException.class, () ->
                SubjectExecutionContext.withSubjectUnchecked(subject, (Callable<Void>) () ->
                {
                    throw expected;
                }));

        assertSame(expected, thrown, "Unexpected exception");
        assertNull(SubjectExecutionContext.currentSubject(), "Subject must be restored after exception");
    }

    @Test
    void testUnwrapSubjectActionException()
    {
        final Exception cause = new Exception("boom");
        final SubjectActionException wrapped = new SubjectActionException(cause);

        final Throwable unwrapped = SubjectExecutionContext.unwrapSubjectActionException(wrapped);

        assertSame(cause, unwrapped, "Unexpected unwrapped exception");
    }

    @Test
    void testUnwrapSubjectActionExceptionDesiredType()
    {
        final IllegalStateException cause = new IllegalStateException("boom");
        final SubjectActionException wrapped = new SubjectActionException(cause);

        final IllegalStateException unwrapped = SubjectExecutionContext.unwrapSubjectActionException(
                wrapped,
                IllegalStateException.class,
                throwable -> new IllegalStateException("fallback", throwable));

        assertSame(cause, unwrapped, "Unexpected unwrapped exception");
    }

    @Test
    void testUnwrapSubjectActionExceptionDesiredTypeMismatchUsesFallback()
    {
        final IllegalStateException cause = new IllegalStateException("boom");
        final SubjectActionException wrapped = new SubjectActionException(cause);

        final IllegalArgumentException fallback = new IllegalArgumentException("fallback", wrapped);

        final IllegalArgumentException unwrapped = SubjectExecutionContext.unwrapSubjectActionException(
                wrapped,
                IllegalArgumentException.class,
                throwable -> fallback);

        assertSame(fallback, unwrapped, "Unexpected unwrapped exception");
    }
}
